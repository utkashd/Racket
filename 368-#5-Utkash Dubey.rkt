#lang web-server/insta

(require mzlib/string)

(struct blog (posts) #:mutable)
(struct post (function variable n point simplify result number))
(define BLOG
  (blog
   '()
   )
  )

(define (blog-insert-post! a-blog a-post)
  (set-blog-posts! a-blog (cons a-post (blog-posts a-blog)))
  )

(define (render-post a-post)
  `(div ((class "text-center") (style "max-width:100%;"))
        (div ((class "post"))
             (div ((class "text-left"))
                  (pre 
                   (p (strong "Function:                ") ,(post-function a-post))
                   (p (strong "Variable:                ") ,(post-variable a-post))
                   (p (strong "N:                       ") ,(post-n a-post))
                   (p (strong "Point:                   ") ,(post-point a-post))
                   (p (strong "Simplify:                ") ,(post-simplify a-post))
                   (p (strong "Nth Symbolic Derivative: ") ,(post-result a-post))
                   (p (strong "Nth Numeric Derivative:  ") ,(post-number a-post))
                   )
                  )
             )
        )
  )

(define (render-posts)
  `(div ((class "posts"))
       ,@(map render-post (blog-posts BLOG))
       )
  )

(define (start request)
  (render-blog-page request))

(define (derive-so-hard f n x1 simple)
  (if (equal? simple "off")
      (expr->string (loop symderiv n f))
      (expr->string (simplify (loop symderiv n f)))
      )
  )

(define (loop f c result)
  (if (= c 0)
      result
      (loop f (- c 1) (f result))
      )
  )

(define (num-deriv f)
  (derivative (eval f env))
  )

(define (numeric-derive-so-hard f n x1)
  (if (> n 0)
      (expr->string ((loop num-deriv (- n 1) (num-deriv f)) x1))
      (expr->string ((eval f env) x1))
      )
  )

(define (parse-post bindings)
  (post 
   (extract-binding/single 'function bindings)
   (extract-binding/single 'variable bindings)
   (extract-binding/single 'n bindings)
   (extract-binding/single 'point bindings)
   (if (= (length bindings) 4) "off" (extract-binding/single 'simplify bindings))
   (derive-so-hard
    (read-from-string (string-append "(lambda(" (extract-binding/single 'variable bindings) ") " (extract-binding/single 'function bindings) ")"))
    (read-from-string (extract-binding/single 'n bindings))
    (read-from-string (extract-binding/single 'point bindings))
    (if (= (length bindings) 4) "off" (extract-binding/single 'simplify bindings))
    )
   (numeric-derive-so-hard
    (read-from-string (string-append "(lambda(" (extract-binding/single 'variable bindings) ") " (extract-binding/single 'function bindings) ")"))
    (read-from-string (extract-binding/single 'n bindings))
    (read-from-string (extract-binding/single 'point bindings))
    )
   )
  )

(define (render-blog-page request)
  (define (response-generator make-url)
    (response/xexpr
     `(html
       (head (title "Symbolic & Numeric Differentiation")
             (meta ((charset "utf-8")))
             (meta ((name "viewport") (content "width=device-width, initial-scale=1.0")))
             (meta ((name "description") (content "Utkash Dubey's 368 project")))
             (meta ((name "author") (content "Utkash Dubey")))
             (link ((rel "shortcut-icon") (href "http://utkashd.tk/favicon.ico")))
             (link ((href "http://utkashd.tk/css/bootstrap-new.min.css") (rel "stylesheet")))
             )
       (body 
        (div ((class "container"))
             (br) (br) (br)
             (div ((class "text-center")) (h1 "Symbolic & Numeric Differentiation")
                  (br)
                  (form ((action ,(make-url insert-post-handler)))
                        (div ((class "container") (style "max-width:100%; width:450px;"))
                             (div ((class "input-group"))
                                  (p (input ((name "function") (class "form-control") (placeholder "Function, i.e. (+ (* x x x) (* x x) x 1)"))))
                                  (p (input ((name "variable") (class "form-control") (placeholder "Variable of differentiation"))))
                                  (p (input ((name "n") (class "form-control") (placeholder "Number of differentiations"))))
                                  (p (input ((name "point") (class "form-control") (placeholder "Point at which derivative should be evaluated"))))
                                  )
                             (p (input ((name "simplify") (type "checkbox")) "Simplify") (input ((type "submit") (class "btn btn-default"))))
                             )
                        )
                  (p (h3 "Hail Archimedes"))
                  (p (h5 "(click image to read about derivatives)"))
                  (div ((class "container"))
                       (a ((href "http://en.wikipedia.org/wiki/Derivative"))
                          (img ((src "http://www.sciencebuddies.org/Files/4054/5/Aero_img084.jpg") (alt "Archimedes")))
                          )
                       )
                  (br) (br)
                  ,(render-posts)
                  )
             )
        ;(script ((src "http://utkashd.tk/js/bootstrap.min.js")))
        ;(script ((src "http://utkashd.tk/js/jquery.js")))
        )) ))
  (define (insert-post-handler request)
    (blog-insert-post! BLOG (parse-post(request-bindings request)))
    (render-blog-page request)
    )
  (send/suspend/dispatch response-generator)
  )

(define (symderiv qf) `(lambda ,(cadr qf) ,(symderivat (caadr qf)(caddr qf))))
(define (symderivat v e)
  (cond ((symbol? e) (if (eq? v e) 1 0))
        ((not  (pair? e)) 0)
        ((not (pair? (cdr e))) 0)
        (else (let ((f (cadr e)))
                (case (car e)
                  ((+ -)   (cons (car e) (map (lambda(x) (symderivat v x)) (cdr e))))
                  ((*)     (cons '+ (map (lambda(x) `(* ,(symderivat v x) ,@(remv x (cdr e)))) (cdr e))))
                  ((/)     (if (pair? (cddr e))
                               (symderivat v `(* ,f(/(* ,@(cddr e)))))
                               `(/ ,(symderivat v f) -1 (expt ,f 2))
                               )
                           )
                  ((exp)  `(* ,e ,(symderivat v f)))
                  ((log)  `(/ ,(symderivat v f) ,f))
                  ((expt) `(* ,e ,(symderivat v `(* ,(caddr e) (log ,f)))))
                  ((sin)  `(*(cos ,f) ,(symderivat v f)))
                  ((cos)  `(* -1 (sin ,f) ,(symderivat v f)))
                  ((tan)  `(/ ,(symderivat v f) (expt (cos ,f) 2)))
                  ((asin) `(/ ,(symderivat v (cadr e)) (expt (- 1 (expt ,f 2)) 1/2)))
                  ((acos) `(/ (- ,(symderivat v f)) (expt (- 1 (expt ,f 2)) 1/2)))
                  ((atan)  (if (null? (cddr e))
                              `(/ ,(symderivat v f) (+ 1 (expt ,f 2)))
                               (symderivat v `(atan (// ,f ,(caddr e))))
                               )
                           )
                  ((abs)  `(* (/ ,f ,e) ,(symderivat v f)))
                  (else 'ERROR-IN-symderiv-------------)
                  )
                )
              )
        )
  )

(define (derivative f)
  (lambda(x) (/ (- (f (+ x dx)) (f x)) dx))
  )
(define dx 1/100000)

(define-namespace-anchor anchor)
(define env (namespace-anchor->namespace anchor))

(define (simplify qf) `(lambda ,(cadr qf) ,(simplify-eval (caddr qf))))

(define (simplify-eval e)
  (if (pair? e) (simplify-apply (cons (car e) (map simplify-eval (cdr e)))) e))

(define (simplify-apply e)
  (case (car e)
    ((+) (s+ e))
    ((-) (s- e))
    ((*) (s* e))
    ((/) (s/ e))
    (else e)
    )
  )

(define (s+ x) (let ((p (remove* '(0) (cdr x))))
                 (case (length p) ((0) 0) ((1) (car p)) (else (cons '+ p)))))
(define (s- x) (if (= (length (cdr x)) 1)
                   (if (equal? (cadr x) 0) 0 x)
                   (if (equal? (cadr x) 0)
                       (s+ (cons '+ (remove* '(0) (cddr x))))
                       (let ((p (s+ (cons '+ (remove* '(0) (cddr x))))))
                         (if (equal? p 0) (cadr x) `(- ,(cadr x) ,p))) )))
(define (s* x) (if (member 0 (cdr x)) 0
                   (let ((p (remove* '(1) (cdr x))))
                     (case (length p) ((0) 1) ((1) (car p)) (else (cons '* p))))))
(define (s/ x) (if (equal? (cadr x) 0) 0 x))

;(map (lambda(qf) (list ((derivative (eval qf env)) 1)
;                       ((eval (symderiv qf) env) 1)
;                       (simplify (symderiv qf))
;                       ))
;     qfs)